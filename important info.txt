What does it mean when a cout is ambiguous?
Ambiguity means there are multiple references to the same keyword: either two libraries have been included that have a cout fuction, or sometimes something gets messy in temporary compiled files. If you think your includes are okay, then cleaning your project or restarting might help.




Topological sort(is kahn's algo is better then another algo?)
Kahn's algorithm and other algorithms for topological sorting serve different purposes and have different characteristics, so it is difficult to say definitively that one is universally better than the other. The choice of algorithm depends on various factors, such as the specific requirements of the problem and the characteristics of the input graph.

Kahn's algorithm is a popular and widely used algorithm for topological sorting. It works based on the concept of indegrees, where it repeatedly selects nodes with zero indegree (i.e., nodes that have no incoming edges) and removes them from the graph, updating the indegrees of the remaining nodes. This process continues until all nodes have been processed, resulting in a valid topological ordering if the graph is a directed acyclic graph (DAG).

One advantage of Kahn's algorithm is that it is simple to understand and implement. It has a time complexity of O(V + E), where V is the number of vertices and E is the number of edges in the graph. This makes it efficient for many practical scenarios.

However, there are other algorithms for topological sorting as well, such as depth-first search (DFS) based algorithms like the one based on recursive DFS or the iterative DFS algorithm called the "stack-based" algorithm. These algorithms may have different time complexities and performance characteristics depending on the graph's structure.

In some cases, DFS-based algorithms may be more suitable, especially when the graph is sparse or when you need to explore specific paths or perform additional operations during the traversal. DFS-based algorithms can also be used to detect cycles in the graph, which Kahn's algorithm does not do explicitly.

In summary, there is no one-size-fits-all answer to whether Kahn's algorithm is better than other algorithms for topological sorting. The choice depends on the specific requirements and characteristics of the problem at hand. Both Kahn's algorithm and DFS-based algorithms have their own advantages and trade-offs, and the most suitable algorithm will vary from case to case.





Bit
ans += 1 << i: This statement adds the value obtained from shifting 1 left by i positions to the variable ans. It effectively sets the i-th bit of ans to 1.
For example, suppose ans is initially 0 (00000000). If you execute ans += 1 << 3, it will set the 3rd bit to 1, resulting in 00001000, which is 8 in decimal.
#include <iostream>

int main() {
    int ans = 0;

    // Set the 0th, 2nd, and 5th bits to 1
    ans += 1 << 0;  // Set 0th bit to 1
    ans += 1 << 2;  // Set 2nd bit to 1
    ans += 1 << 5;  // Set 5th bit to 1

    std::cout << "Result: " << ans << std::endl;

    return 0;
}







if (s[i] == " " && c > 0) return c; //error
By using single quotes (' ') instead of double quotes (" "), you are now comparing the character s[i] against the character literal for a space, which is valid and eliminates the warning.






fmod(x, 1) calculates the remainder when x is divided by 1. It returns the fractional part of x. In this case, x is the logarithm of n to the base 3.

The expression fmod(x, 1) calculates the fractional part of a number x. The fmod function is part of the <cmath> library in C++, and it returns the remainder when x is divided by 1.

In mathematical terms, if x is a real number, fmod(x, 1) gives you the decimal part of x. It effectively removes the whole number part of x and returns the fractional part.

For example:

fmod(5.7, 1) would return 0.7 because the integer part of 5.7 is 5, and the remainder is the fractional part.
fmod(-3.2, 1) would return -0.2 because the integer part of -3.2 is -3, and the remainder is the fractional part.
The result of fmod(x, 1) is always between 0 and 1 (excluding 1). If the fractional part is exactly 0, it means that x is an integer. If the fractional part is non-zero, it means that x is not an integer.

It's worth noting that when x is an integer, fmod(x, 1) will always return 0.0.
